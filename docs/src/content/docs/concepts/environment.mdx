---
title: Environment
description: Understanding Odin environments and how to manage them
---

An **Environment** in Odin is an isolated namespace for deploying services. It represents a stage in your development lifecycle and provides logical separation between different deployment contexts.

## What is an Environment?

Environments allow you to:

- Deploy the same service to different stages (dev, staging, production)
- Isolate deployments from each other
- Associate services with specific cloud provider accounts
- Manage service lifecycle independently per environment

## Environment Properties

Each environment has the following properties:

- **Name**: Unique identifier (e.g., `dev`, `staging`, `production`)
- **Organization ID**: The organization that owns the environment
- **Provider Accounts**: One or more cloud provider accounts associated with the environment
- **Provisioning Type**: Default provisioning strategy (e.g., `kubernetes`, `ec2`)
- **Status**: Current state (CREATING, READY, DELETING, DELETED)
- **Auto-deletion Time**: Optional scheduled cleanup for ephemeral environments

## Environment Lifecycle

### Creating an Environment

Create a new environment using the CLI:

```bash
odin create env <env-name> --accounts <account1>,<account2>
```

**Example:**
```bash
odin create env staging --accounts aws/dev,aws/shared
```

This creates an environment named "staging" associated with two AWS accounts.

### Listing Environments

List all environments you have access to:

```bash
odin list env
```

Filter by provider account:

```bash
odin list env --account aws/production
```

Include environments from other users (requires access):

```bash
odin list env --all
```

### Describing an Environment

Get detailed information about an environment:

```bash
odin describe env <env-name>
```

Filter by service or component:

```bash
odin describe env staging --service my-service
odin describe env staging --service my-service --component database
```

### Checking Environment Status

Check the deployment status of an environment:

```bash
odin status env <env-name>
```

Get status for a specific service:

```bash
odin status env staging --service my-service
```

### Deleting an Environment

Delete an environment and all its services:

```bash
odin delete env <env-name>
```

:::caution[Warning]
Deleting an environment will undeploy all services within it. This operation cannot be undone.
:::

## Environment States

Environments transition through several states:

| State | Description |
|-------|-------------|
| `CREATING` | Environment is being provisioned |
| `READY` | Environment is available for deployments |
| `DELETING` | Environment is being torn down |
| `DELETED` | Environment has been removed |

## Environment Best Practices

### Naming Conventions

Use clear, consistent names for environments:

- `dev` or `development`: Developer environments
- `qa` or `staging`: Testing and QA environments
- `prod` or `production`: Production environments
- `feature-<name>`: Feature-specific ephemeral environments

### Multi-Account Strategy

Separate environments by purpose:

```bash
# Development environment
odin create env dev --accounts aws/dev-account

# Staging environment (dev + shared services)
odin create env staging --accounts aws/dev-account,aws/shared-services

# Production environment
odin create env prod --accounts aws/prod-account,aws/shared-services
```

### Ephemeral Environments

Create temporary environments for feature branches:

```bash
odin create env feature-auth-v2 --accounts aws/dev-account
# ... deploy and test ...
odin delete env feature-auth-v2
```

### Default Environment

Set a default environment for your profile to avoid typing `--env` every time:

```bash
odin set env staging
```

Now all commands will use "staging" unless you specify a different `--env`.

## Environment Isolation

Environments provide isolation at multiple levels:

1. **Resource Isolation**: Services in different environments use separate cloud resources
2. **Namespace Isolation**: Kubernetes deployments use environment-specific namespaces
3. **Configuration Isolation**: Each environment can have different provisioning configs
4. **Access Control**: Environments can have different access policies

## Examples

### Create a Development Environment

```bash
odin create env dev --accounts aws/dev
```

### Create a Production Environment with Multiple Accounts

```bash
odin create env production \
  --accounts aws/prod-compute,aws/prod-data,aws/shared-services
```

### Check All Services in an Environment

```bash
odin status env staging
```

Output:
```
Environment: staging
Status: READY

Services:
┌──────────────┬─────────┬────────────┬────────────┐
│ Service      │ Version │ Status     │ Components │
├──────────────┼─────────┼────────────┼────────────┤
│ user-api     │ 1.2.0   │ DEPLOYED   │ 3          │
│ payment-svc  │ 2.0.1   │ DEPLOYED   │ 2          │
│ analytics    │ 1.0.0   │ DEPLOYING  │ 4          │
└──────────────┴─────────┴────────────┴────────────┘
```

### Delete an Ephemeral Environment

```bash
odin delete env feature-new-dashboard
```

## Related Concepts

- [Service](/odin/concepts/service): Deploy services to environments
- [Provisioning](/odin/concepts/provisioning): Configure how components are deployed in environments
- [Versioning](/odin/concepts/versioning): Manage service versions across environments
